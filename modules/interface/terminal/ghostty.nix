{ config, pkgs, lib, userState, ... }:

let
  enabled = userState.interface.terminal.ghostty.enable or true;
  
  # Helper to read optional config files
  readConfig = path: if builtins.pathExists path then builtins.readFile path else "";
  
  # Configuration layers
  # Note: paths are relative to THIS file
  defaultConfig = readConfig ../../../config/cafaye/ghostty/config;
  userConfig = readConfig ../../../config/user/ghostty/config;
in
{
  config = lib.mkIf enabled {
    # Ghostty is currently not supported in Nixpkgs for aarch64-darwin.
    # We install it only on Linux and x86_64-darwin (if supported).
    # For aarch64-darwin, we assume the user installs it via brew but manage the config.
    home.packages = lib.optionals (pkgs.stdenv.isLinux || (pkgs.stdenv.isDarwin && pkgs.stdenv.isx86_64)) [ 
      pkgs.ghostty 
    ];
    
    xdg.configFile."ghostty/config" = {
      text = ''
        # ═══════════════════════════════════════════════════════════════════
        # CAFAYE GHOSTTY CONFIGURATION
        # Managed by Nix/Home Manager - DO NOT EDIT THIS FILE DIRECTLY
        # ═══════════════════════════════════════════════════════════════════
        
        # --- [ LAYER 1: CAFAYE DEFAULTS ] ---
        ${defaultConfig}
        
        # --- [ LAYER 2: USER OVERRIDES ] ---
        ${userConfig}
      '';
    };

    # Keep canonical config path as a symlink into Cafaye-managed defaults.
    home.activation.cafayeGhosttyConfigSymlink = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      mkdir -p "$HOME/.config"
      if [ -d "$HOME/.config/ghostty" ] && [ ! -L "$HOME/.config/ghostty" ]; then
        rm -rf "$HOME/.config/ghostty"
      fi
      ln -sfn "$HOME/.config/cafaye/config/cafaye/ghostty" "$HOME/.config/ghostty"
    '';
  };
}
